(** Here we define the signature for the circle *)
Require Import UniMath.Foundations.All.
Require Import UniMath.MoreFoundations.All.

Require Import UniMath.CategoryTheory.Core.Categories.
Require Import UniMath.CategoryTheory.Groupoids.
Require Import UniMath.Bicategories.Core.Bicat.
Import Bicat.Notations.
Require Import UniMath.Bicategories.Core.Examples.OneTypes.
Require Import UniMath.Bicategories.Colimits.Initial.
Require Import UniMath.Bicategories.PseudoFunctors.PseudoFunctor.

Require Import prelude.all.
Require Import signature.hit_signature.
Require Import signature.hit.
Require Import algebra.one_types_polynomials.
Require Import algebra.one_types_endpoints.
Require Import algebra.one_types_homotopies.
Require Import displayed_algebras.displayed_algebra.

Local Open Scope cat.

Definition TODO {A : UU} : A.
Admitted.

Definition poly_id_comp
           (P : poly_code)
           {X Y : UU}
           (f : X → Y)
           (x : poly_act P X)
  : poly_id P Y (poly_map P f x) @ poly_comp P f (λ z, z) x
    =
    poly_homot P (λ z, idpath _) x.
Proof.
  induction P as [ T | | P₁ IHP₁ P₂ IHP₂ | P₁ IHP₁ P₂ IHP₂ ].
  - apply idpath.
  - apply idpath.
  - induction x as [x | x] ; simpl.
    + exact (!(maponpathscomp0 _ _ _) @ maponpaths (maponpaths inl) (IHP₁ _)).
    + exact (!(maponpathscomp0 _ _ _) @ maponpaths (maponpaths inr) (IHP₂ _)).
  - exact (pathsdirprod_concat _ _ _ _ @ paths_pathsdirprod (IHP₁ _) (IHP₂ _)).
Defined.

(**
Lemmata on carriers of 2-cells.
In certain cases, unfolding the definitions is slow.
For this reason, we make separate lemmas, which are faster to use.
 *)
Definition alg_2cell_vcomp
           {Σ : hit_signature}
           {X Y : hit_algebra_one_types Σ}
           {f g h : X --> Y}
           (τ : f ==> g)
           (θ : g ==> h)
  : alg_2cell_carrier (τ • θ)
    =
    homotcomp
      (alg_2cell_carrier τ)
      (alg_2cell_carrier θ)
  := idpath _.

Definition alg_2cell_rwhisker
           {Σ : hit_signature}
           {X Y Z : hit_algebra_one_types Σ}
           {f g : X --> Y}
           (τ : f ==> g)
           (h : Y --> Z)
  : alg_2cell_carrier (τ ▹ h)
    =
    λ z, maponpaths (alg_map_carrier h) (alg_2cell_carrier τ z)
  := idpath _.

Definition alg_2cell_inv
           {Σ : hit_signature}
           {X Y : hit_algebra_one_types Σ}
           {f g : X --> Y}
           (τ : f ==> g)
  : alg_2cell_carrier
      ((hit_alg_is_invertible_2cell_one_type Σ τ)^-1)
    =
    invhomot (alg_2cell_carrier τ)
  := idpath _.

(** Free `Σ'-algebra generated by `A` *)
Section FreeAlg.
  Variable (Σ : hit_signature)
           (A : one_type).

  Definition free_alg_signature_point_constr
    : poly_code
    := point_constr Σ + C A.

  Definition to_free_alg_endpoint
             {P Q : poly_code}
             (e : endpoint (point_constr Σ) P Q)
    : endpoint free_alg_signature_point_constr P Q.
  Proof.
    induction e as [P | P Q R e₁ IHe₁ e₂ IHe₂
                    | P Q | P Q | P Q | P Q
                    | P Q R e₁ IHe₁ e₂ IHe₂
                    | P T t | C₁ C₂ g | ].
    - (* identity *)
      exact (id_e _ _).
    - (* composition *)
      exact (comp IHe₁ IHe₂).
    - (* left inclusion *)
      exact (ι₁ _ _).
    - (* right inclusion *)
      exact (ι₂ _ _).
    - (* left projection *)
      exact (π₁ _ _).
    - (* right projection *)
      exact (π₂ _ _).
    - (* pair *)
      exact (pair IHe₁ IHe₂).
    - (* constant element *)
      exact (c _ t).
    - (* constant map *)
      exact (fmap g).
    - (* constructor *)
      exact (comp (ι₁ _ _) constr).
  Defined.

  Definition free_alg_signature_path_left
             (j : path_label Σ)
    : endpoint free_alg_signature_point_constr (path_source Σ j) I
    := to_free_alg_endpoint (path_left Σ j).

  Definition free_alg_signature_path_right
             (j : path_label Σ)
    : endpoint free_alg_signature_point_constr (path_source Σ j) I
    := to_free_alg_endpoint (path_right Σ j).

  Definition free_alg_signature_path_arg_left
             (j : homot_label Σ)
    : endpoint
        free_alg_signature_point_constr
        (homot_point_arg Σ j)
        (homot_path_arg_target Σ j)
    := to_free_alg_endpoint (homot_path_arg_left Σ j).

  Definition free_alg_signature_path_arg_right
             (j : homot_label Σ)
    : endpoint
        free_alg_signature_point_constr
        (homot_point_arg Σ j)
        (homot_path_arg_target Σ j)
    := to_free_alg_endpoint (homot_path_arg_right Σ j).

  Definition free_alg_signature_homot_left_endpoint
             (j : homot_label Σ)
    : endpoint free_alg_signature_point_constr (homot_point_arg Σ j) I
    := to_free_alg_endpoint (homot_left_endpoint Σ j).

  Definition free_alg_signature_homot_right_endpoint
             (j : homot_label Σ)
    : endpoint free_alg_signature_point_constr (homot_point_arg Σ j) I
    := to_free_alg_endpoint (homot_right_endpoint Σ j).

  Definition free_alg_signature_homot_endpoint
             {Q TR T : poly_code}
             {al ar : endpoint (point_constr Σ) Q TR}
             {sl sr : endpoint (point_constr Σ) Q T}
             (p : homot_endpoint
                    (path_left Σ)
                    (path_right Σ)
                    al ar
                    sl sr)
    : homot_endpoint
        free_alg_signature_path_left
        free_alg_signature_path_right
        (to_free_alg_endpoint al)
        (to_free_alg_endpoint ar)
        (to_free_alg_endpoint sl)
        (to_free_alg_endpoint sr).
  Proof.
    induction p as [T e | T e₁ e₂ p IHp | T e₁ e₂ e₃ p₁ IHp₁ p₂ IHp₂
                    | T₁ T₂ e₁ e₂ e₃ h IHh
                    | R₁ R₂ T e₁ e₂ e₃ | T e | T e
                    | P R e₁ e₂ | P R e₁ e₂
                    | T₁ T₂ e₁ e₂ e₃ e₄ p₁ IHp₁ p₂ IHp₂
                    | P₁ P₂ P₃ e₁ e₂ e₃
                    | Z x T e | j e | ].
    - (* reflexivity *)
      exact (refl_e _).
    - (* symmetry *)
      exact (inv_e IHp).
    - (* transitivity *)
      exact (trans_e IHp₁ IHp₂).
    - (* ap *)
      exact (ap_e (to_free_alg_endpoint e₃) IHh).
    - (* associativity of composition *)
      apply comp_assoc.
    - (* left unitality *)
      apply comp_id_l.
    - (* right unitality *)
      apply comp_id_r.
    - (* first projection of pair *)
      apply pair_π₁.
    - (* second projection of pair *)
      apply pair_π₂.
    - (* pair of paths *)
      exact (path_pair IHp₁ IHp₂).
    - (* composition with pair *)
      apply comp_pair.
    - (* composition with constant *)
      apply comp_constant.
    - (* path constructor *)
      exact (path_constr j (to_free_alg_endpoint e)).
    - (* path argument *)
      apply path_arg.
  Defined.

  Definition free_alg_signature_homot_left_path
             (j : homot_label Σ)
    : homot_endpoint
        free_alg_signature_path_left
        free_alg_signature_path_right
        (free_alg_signature_path_arg_left j)
        (free_alg_signature_path_arg_right j)
        (free_alg_signature_homot_left_endpoint j)
        (free_alg_signature_homot_right_endpoint j)
    := free_alg_signature_homot_endpoint (homot_left_path Σ j).

  Definition free_alg_signature_homot_right_path
             (j : homot_label Σ)
    : homot_endpoint
        free_alg_signature_path_left
        free_alg_signature_path_right
        (free_alg_signature_path_arg_left j)
        (free_alg_signature_path_arg_right j)
        (free_alg_signature_homot_left_endpoint j)
        (free_alg_signature_homot_right_endpoint j)
    := free_alg_signature_homot_endpoint (homot_right_path Σ j).
 
  Definition free_alg_signature
    : hit_signature.
  Proof.
    simple refine (_ ,, _ ,, _ ,, _ ,, _ ,, _ ,, _ ,, _ ,, _ ,, _  ,, _ ,, _ ,, _ ,, _).
    - exact free_alg_signature_point_constr.
    - exact (path_label Σ).
    - exact (path_source Σ).
    - exact free_alg_signature_path_left.
    - exact free_alg_signature_path_right.
    - exact (homot_label Σ).
    - exact (homot_point_arg Σ).
    - exact (homot_path_arg_target Σ).
    - exact free_alg_signature_path_arg_left.
    - exact free_alg_signature_path_arg_right.
    - exact free_alg_signature_homot_left_endpoint.
    - exact free_alg_signature_homot_right_endpoint.
    - exact free_alg_signature_homot_left_path.
    - exact free_alg_signature_homot_right_path.
  Defined.

  (** Necessary lemma *)
  Definition free_alg_sem_endpoint_UU
             {P Q : poly_code}
             (e : endpoint (point_constr Σ) P Q)
             {X : UU}
             (c : poly_act (point_constr Σ) X ⨿ A → X)
             (x : poly_act P X)
    : sem_endpoint_UU e (λ z, c(inl z)) x
      =
      sem_endpoint_UU (to_free_alg_endpoint e) c x.
  Proof.
    induction e as [P | P Q R e₁ IHe₁ e₂ IHe₂
                    | P Q | P Q | P Q | P Q
                    | P Q R e₁ IHe₁ e₂ IHe₂
                    | P T t | C₁ C₂ g | ].
    - (* identity *)
      apply idpath.
    - (* composition *)
      exact (maponpaths _ (IHe₁ _) @ IHe₂ _).
    - (* left inclusion *)
      apply idpath.
    - (* right inclusion *)
      apply idpath.
    - (* left projection *)
      apply idpath.
    - (* right projection *)
      apply idpath.
    - (* pair *)
      exact (pathsdirprod (IHe₁ _) (IHe₂ _)).
    - (* constant element *)
      apply idpath.
    - (* constant map *)
      apply idpath.
    - (* constructor *)
      apply idpath.
  Defined.

  Definition free_alg_sem_endpoint_UU_natural
             {P Q : poly_code}
             (e : endpoint (point_constr Σ) P Q)
             {X Y : UU}
             {cX : poly_act (point_constr Σ) X ⨿ A → X}
             {cY : poly_act (point_constr Σ) Y ⨿ A → Y}
             {f : X → Y}
             (cf : ∏ x, f(cX x) = cY (poly_map (point_constr Σ + C A) f x))
             (x : poly_act P X)
    : sem_endpoint_UU_natural (to_free_alg_endpoint e) cf x
      =
      maponpaths (poly_map Q f) (!(free_alg_sem_endpoint_UU e cX x))
      @ sem_endpoint_UU_natural e (λ z, cf(inl z)) x
      @ free_alg_sem_endpoint_UU e cY (poly_map P f x).
  Proof.
    induction e as [P | P Q R e₁ IHe₁ e₂ IHe₂
                    | P Q | P Q | P Q | P Q
                    | P Q R e₁ IHe₁ e₂ IHe₂
                    | P T t | C₁ C₂ g | ].
    - (* identity *)
      apply idpath.
    - (* composition *)
      simpl.
      etrans.
      {
        apply maponpaths_2.
        apply IHe₂.
      }
      clear IHe₂.
      etrans.
      {
        do 2 apply maponpaths.
        apply IHe₁.
      }
      clear IHe₁.
      refine (!(path_assoc _ _ _) @ _).
      refine (!_).
      etrans.
      {
        apply maponpaths_2.
        etrans.
        {
          apply maponpaths.
          apply pathscomp_inv.
        }
        apply maponpathscomp0.
      }
      refine (!(path_assoc _ _ _) @ _).
      apply maponpaths.
      refine (!_).
      etrans.
      {
        apply maponpaths.
        etrans.
        {
          apply maponpaths.
          apply path_assoc.
        }
        apply maponpathscomp0.
      }
      refine (path_assoc _ _ _ @ _).
      refine (!_).
      refine (path_assoc _ _ _ @ _).
      etrans.
      {
        apply maponpaths.
        apply homotsec_natural'.
      }
      refine (path_assoc _ _ _ @ _).
      apply maponpaths_2.
      refine (!(path_assoc _ _ _) @ _).
      etrans.
      {
        apply maponpaths.
        refine (!(path_assoc _ _ _) @ _).
        apply maponpaths.
        apply homotsec_natural'.
      }
      do 2 refine (path_assoc _ _ _ @ _).
      refine (!_).
      etrans.
      {
        apply maponpaths.
        apply maponpathscomp0.
      }
      refine (path_assoc _ _ _ @ _).
      apply maponpaths_2.
      refine (!path_assoc _ _ _ @ _).
      etrans.
      {
        apply maponpaths.
        etrans.
        {
          apply maponpaths.
          apply maponpathscomp.
        }
        refine (!_).
        apply (homotsec_natural'
                 (λ z, free_alg_sem_endpoint_UU
                         e₂ cY (poly_map Q f z))).
      }
      refine (path_assoc _ _ _ @ _).
      apply maponpaths_2.
      etrans.
      {
        refine (!_).
        apply (homotsec_natural'
                 (sem_endpoint_UU_natural
                    e₂
                    (λ z : poly_act (point_constr Σ) X, cf (inl z)))).
      }
      apply maponpaths_2.
      refine (!_).
      etrans.
      {
        apply maponpaths.
        refine (!_).
        apply maponpathsinv0.
      }
      apply maponpathscomp.
    - (* left inclusion *)
      apply idpath.
    - (* right inclusion *)
      apply idpath.
    - (* left projection *)
      apply idpath.
    - (* right projection *)
      apply idpath.
    - (* pair *)
      simpl.
      refine (!_).
      etrans.
      {
        etrans.
        {
          apply maponpaths_2.
          etrans.
          {
            apply maponpaths.
            apply pathsdirprod_inv.
          }
          refine (!_).
          apply maponpaths_pathsdirprod.
        }
        etrans.
        {
          apply maponpaths.
          apply pathsdirprod_concat.
        }
        apply pathsdirprod_concat.
      }
      refine (!_).
      exact (paths_pathsdirprod (IHe₁ _) (IHe₂ _)).
    - (* constant element *)
      apply idpath.
    - (* constant map *)
      apply idpath.
    - (* constructor *)
      apply idpath.
  Qed.
  
  Definition free_alg_sem_endpoint_UU_natural'
             {P Q : poly_code}
             (e : endpoint (point_constr Σ) P Q)
             {X Y : UU}
             {cX : poly_act (point_constr Σ) X ⨿ A → X}
             {cY : poly_act (point_constr Σ) Y ⨿ A → Y}
             {f : X → Y}
             (cf : ∏ x, f(cX x) = cY (poly_map (point_constr Σ + C A) f x))
             (x : poly_act P X)
    : maponpaths (poly_map Q f) (free_alg_sem_endpoint_UU e cX x)
      @ sem_endpoint_UU_natural (to_free_alg_endpoint e) cf x
      @ !(free_alg_sem_endpoint_UU e cY (poly_map P f x))
      =
      sem_endpoint_UU_natural e (λ z, cf(inl z)) x.
  Proof.
    etrans.
    {
      apply maponpaths.
      etrans.
      {
        apply maponpaths_2.
        apply free_alg_sem_endpoint_UU_natural.
      }
      refine (!(path_assoc _ _ _) @ _).
      apply maponpaths.
      refine (!(path_assoc _ _ _) @ _).
      etrans.
      {
        apply maponpaths.
        apply pathsinv0r.
      }
      apply pathscomp0rid.
    }
    refine (path_assoc _ _ _ @ _).
    etrans.
    {
      apply maponpaths_2.
      etrans.
      {
        refine (!_).
        apply maponpathscomp0.
      }
      apply maponpaths.
      apply pathsinv0r.
    }
    apply idpath.
  Qed.

  (** Projections of an algebra *)             
  Section FreeAlgProjections.
    Variable (X : hit_algebra_one_types free_alg_signature).

    Definition free_alg_is_prealg
      : hit_prealgebra_one_types Σ.
    Proof.
      use make_hit_prealgebra.
      - exact (alg_carrier X).
      - apply (one_type_isofhlevel (pr111 X)).
      - exact (λ x, alg_constr X (inl x)).
    Defined.

    Definition free_alg_is_path_alg
      : hit_path_algebra_one_types Σ.
    Proof.
      use make_hit_path_algebra.
      - exact free_alg_is_prealg.
      - exact (λ j x,
               free_alg_sem_endpoint_UU _ _ _
               @ alg_path X j x
               @ !(free_alg_sem_endpoint_UU _ _ _)).
    Defined.

    Definition free_alg_is_alg_homot
      : is_hit_algebra_one_types Σ free_alg_is_path_alg.
    Proof.
      intros j x p.
      apply TODO.
    Qed.

    Definition free_alg_is_alg
      : hit_algebra_one_types Σ.
    Proof.
      use make_algebra.
      - exact free_alg_is_path_alg.
      - exact free_alg_is_alg_homot.
    Defined.

    Definition free_alg_inc
      : A → alg_carrier free_alg_is_alg
      := λ a, alg_constr X (inr a).
  End FreeAlgProjections.

  (** Builder of algebras *)
  Section FreeAlgBuilder.
    Variable (X : hit_algebra_one_types Σ)
             (inc : A → alg_carrier X).
    
    Definition free_alg_point_constr
      : poly_act (point_constr free_alg_signature) (alg_carrier X)
        →
        alg_carrier X.
    Proof.
      intro x.
      induction x as [x | x].
      - exact (alg_constr X x).
      - exact (inc x).
    Defined.      

    Definition make_free_alg_prealgebra
      : hit_prealgebra_one_types free_alg_signature.
    Proof.
      use make_hit_prealgebra.
      - exact (alg_carrier X).
      - apply (one_type_isofhlevel (pr111 X)).
      - exact free_alg_point_constr.
    Defined.

    Definition make_free_alg_path_algebra
      : hit_path_algebra_one_types free_alg_signature.
    Proof.
      use make_hit_path_algebra.
      - exact make_free_alg_prealgebra.
      - exact (λ j x,
               !(free_alg_sem_endpoint_UU _ _ _)
               @ alg_path X j x
               @ free_alg_sem_endpoint_UU _ _ _).
    Defined.
    
    Definition make_free_alg_algebra
      : hit_algebra_one_types free_alg_signature.
    Proof.
      use make_algebra.
      - exact make_free_alg_path_algebra.
      - apply TODO.
    Defined.
  End FreeAlgBuilder.

  Section FreeAlgMakeFreeAlg.
    Variable (X : hit_algebra_one_types Σ)
             (inc : A → alg_carrier X).

    Local Definition free_alg_is_alg_make_free_alg_algebra_prealg
      : pr11 (free_alg_is_alg (make_free_alg_algebra X inc)) --> pr11 X.
    Proof.
      use make_hit_prealgebra_mor.
      - exact (λ z, z).
      - exact (λ z,
               maponpaths
                 (alg_constr X)
                 (poly_id (point_constr Σ) (alg_carrier X) z)).
    Defined.

    Local Definition free_alg_to_make_free_alg_sem_endpoint
          {P Q : poly_code}
          (e : endpoint (point_constr Σ) P Q)
          (x : poly_act P (alg_carrier X))
      : sem_endpoint_UU_natural
          e
          (prealg_map_commute free_alg_is_alg_make_free_alg_algebra_prealg)
          x
        =
        !(poly_id _ _ _)
        @ maponpaths
            (sem_endpoint_UU e prealg_constr)
            (poly_id _ _ _).
    Proof.
      induction e as [P | P Q R e₁ IHe₁ e₂ IHe₂
                      | P Q | P Q | P Q | P Q
                      | P Q R e₁ IHe₁ e₂ IHe₂
                      | P T t | C₁ C₂ g | ]
      ; simpl.
      - refine (!_).
        etrans.
        {
          apply maponpaths.
          apply maponpathsidfun.
        }
        apply pathsinv0l.
      - etrans.
        {
          apply maponpaths_2.
          apply IHe₂.
        }
        refine (!(path_assoc _ _ _) @ _).
        apply maponpaths.
        etrans.
        {
          refine (!_).
          apply maponpathscomp0.
        }
        refine (!_).
        etrans.
        {
          refine (!_).
          apply maponpathscomp.
        }
        refine (!_).
        apply maponpaths.
        etrans.
        {
          apply maponpaths.
          apply IHe₁.
        }
        refine (path_assoc _ _ _ @ _).
        etrans.
        {
          apply maponpaths_2.
          apply pathsinv0r.
        }
        apply idpath.
      - exact (!(pathsinv0l _)).
      - exact (!(pathsinv0l _)).
      - refine (!_).
        etrans.
        {
          apply maponpaths.
          apply maponpaths_pr1_pathsdirprod.
        }
        apply pathsinv0l.
      - refine (!_).
        etrans.
        {
          apply maponpaths.
          apply maponpaths_pr2_pathsdirprod.
        }
        apply pathsinv0l.
      - refine (!_).
        etrans.
        {
          etrans.
          {
            apply maponpaths.
            apply maponpaths_prod_path.
          }
          etrans.
          {
            apply maponpaths_2.
            apply pathsdirprod_inv.
          }
          apply pathsdirprod_concat.
        }
        refine (!_).
        exact (paths_pathsdirprod (IHe₁ _) (IHe₂ _)).
      - exact (!(maponpaths_for_constant_function _ _)).
      - apply idpath.
      - apply idpath.
    Qed.

    Local Definition free_alg_is_alg_make_free_alg_algebra_preserves_path
      : preserves_path
          _
          (prealg_map_commute free_alg_is_alg_make_free_alg_algebra_prealg).
    Proof.
      intros j x.
      simpl.
      refine (!_).
      etrans.
      {
        apply maponpaths_2.
        exact (free_alg_to_make_free_alg_sem_endpoint (path_left Σ j) x).
      }
      simpl.
      etrans.
      {
        apply homotsec_natural'.
      }
      refine (!_).
      etrans.
      {
        apply maponpaths_2.
        apply maponpathsidfun.
      }
      etrans.
      {
        apply maponpaths.
        exact (free_alg_to_make_free_alg_sem_endpoint (path_right Σ j) x).
      }
      simpl.
      apply maponpaths_2.
      unfold alg_path ; simpl.
      etrans.
      {
        refine (path_assoc _ _ _ @ _).
        etrans.
        {
          apply maponpaths_2.
          refine (path_assoc _ _ _ @ _).
          apply maponpaths_2.
          apply pathsinv0r.
        }
        simpl.
        refine (!(path_assoc _ _ _) @ _).
        etrans.
        {
          apply maponpaths.
          apply pathsinv0r.
        }
        apply pathscomp0rid.
      }
      apply idpath.
    Qed.

    Definition free_alg_is_alg_make_free_alg_algebra
      : free_alg_is_alg (make_free_alg_algebra X inc) --> X.
    Proof.
      use make_algebra_map.
      use make_hit_path_alg_map.
      - exact free_alg_is_alg_make_free_alg_algebra_prealg.
      - exact free_alg_is_alg_make_free_alg_algebra_preserves_path.
    Defined.


    Local Definition free_alg_is_alg_make_free_alg_algebra_prealg_inv
      : pr11 X --> pr11 (free_alg_is_alg (make_free_alg_algebra X inc)).
    Proof.
      use make_hit_prealgebra_mor.
      - exact (λ z, z).
      - exact (λ z,
               maponpaths
                 (alg_constr X)
                 (poly_id (point_constr Σ) (alg_carrier X) z)).
    Defined.

    Local Definition free_alg_is_alg_make_free_alg_algebra_preserves_path_inv
      : preserves_path
          _
          (prealg_map_commute free_alg_is_alg_make_free_alg_algebra_prealg_inv).
    Proof.
      intros j x.
      simpl.
      refine (!_).
      etrans.
      {
        apply maponpaths_2.
        exact (free_alg_to_make_free_alg_sem_endpoint (path_left Σ j) x).
      }
      simpl.
      unfold alg_path.
      simpl.
      etrans.
      {
        apply maponpaths.
        etrans.
        {
          do 2 (refine (path_assoc _ _ _ @ _) ; apply maponpaths_2).
          apply pathsinv0r.
        }
        simpl.
        refine (!(path_assoc _ _ _) @ _).
        etrans.
        {
          apply maponpaths.
          apply pathsinv0r.
        }
        apply pathscomp0rid.
      }
      simpl.
      refine (!_).
      etrans.
      {
        apply maponpaths_2.
        apply maponpathsidfun.
      }
      etrans.
      {
        apply maponpaths.
        exact (free_alg_to_make_free_alg_sem_endpoint (path_right Σ j) x).
      }
      simpl.
      refine (!_).
      apply homotsec_natural'.
    Qed.    
    
    Definition free_alg_is_alg_make_free_alg_algebra_inv
      : X --> free_alg_is_alg (make_free_alg_algebra X inc).
    Proof.
      use make_algebra_map.
      use make_hit_path_alg_map.
      - exact free_alg_is_alg_make_free_alg_algebra_prealg_inv.
      - exact free_alg_is_alg_make_free_alg_algebra_preserves_path_inv.
    Defined.
  End FreeAlgMakeFreeAlg.

  (** Projections of 1-cells *)
  Definition preserves_A
             {X Y : hit_algebra_one_types Σ}
             (f : X --> Y)
             (Xa : A → alg_carrier X)
             (Ya : A → alg_carrier Y)
    : UU
    := ∏ (a : A),
       alg_map_carrier f (Xa a) = Ya a.
  
  Section FreeAlgMapProjections.
    Context {X Y : hit_algebra_one_types free_alg_signature}
            (f : X --> Y).

    Definition free_alg_map_prealg_mor
      : pr11 (free_alg_is_alg X) --> pr11 (free_alg_is_alg Y).
    Proof.
      use make_hit_prealgebra_mor.
      - exact (alg_map_carrier f).
      - exact (λ x, alg_map_commute f (inl x)).
    Defined.

    Definition free_alg_map_preserves_path
      : preserves_path _ (prealg_map_commute free_alg_map_prealg_mor).
    Proof.
      intros j x.
      etrans.
      {
        apply maponpaths.
        refine (!_).
        apply (free_alg_sem_endpoint_UU_natural' (path_right Σ j)).
      }
      simpl.
      refine (path_assoc _ _ _ @ _).
      etrans.
      {
        apply maponpaths_2.
        etrans.
        {
          refine (!_).
          apply maponpathscomp0.
        }
        apply maponpaths.
        refine (!(path_assoc _ _ _) @ _).
        apply maponpaths.
        refine (!(path_assoc _ _ _) @ _).
        etrans.
        {
          apply maponpaths.
          apply pathsinv0l.
        }
        apply pathscomp0rid.
      }
      refine (path_assoc _ _ _ @ _).
      do 2 refine (_ @ !(path_assoc _ _ _)).
      apply maponpaths_2.
      etrans.
      {
        apply maponpaths_2.
        apply maponpathscomp0.
      }
      refine (!(path_assoc _ _ _) @ _).
      etrans.
      {
        apply maponpaths.
        exact (alg_map_path f j x).
      }
      refine (path_assoc _ _ _ @ _).
      apply maponpaths_2.
      refine (!_).
      etrans.
      {
        apply maponpaths_2.
        refine (!_).
        apply (free_alg_sem_endpoint_UU_natural' (path_left Σ j)).
      }
      simpl.
      refine (!(path_assoc _ _ _) @ _).
      apply maponpaths.
      refine (!(path_assoc _ _ _) @ _).
      refine (_ @ pathscomp0rid _).
      apply maponpaths.
      apply pathsinv0l.
    Qed.
        
    Definition free_alg_map_alg_mor
      : free_alg_is_alg X --> free_alg_is_alg Y.
    Proof.
      use make_algebra_map.
      use make_hit_path_alg_map.
      - exact free_alg_map_prealg_mor.
      - exact free_alg_map_preserves_path.
    Defined.

    Definition free_alg_map_on_A
      : preserves_A
          free_alg_map_alg_mor
          (free_alg_inc X)
          (free_alg_inc Y)
      := λ a, alg_map_commute f (inr a).
  End FreeAlgMapProjections.

  Section FreeAlgMapBuilder.
    Context {X : hit_algebra_one_types free_alg_signature}
            {Y : hit_algebra_one_types Σ}
            (incY : A → alg_carrier Y)
            (f : free_alg_is_alg X --> Y)
            (Hf : preserves_A f (free_alg_inc X) incY).
    
    Definition make_free_alg_prealg_mor
      : pr11 X --> pr11 (make_free_alg_algebra Y incY).
    Proof.
      use make_hit_prealgebra_mor.
      - exact (alg_map_carrier f).
      - intro x.
        induction x as [x | x].
        + exact (alg_map_commute f x).
        + exact (Hf x).
    Defined.

    Definition make_free_alg_preserves_path
      : preserves_path _ (prealg_map_commute make_free_alg_prealg_mor).
    Proof.
      intros j x ; simpl.
      etrans.
      {
        apply maponpaths.
        apply (free_alg_sem_endpoint_UU_natural (path_right _ _)).
      }
      refine (!_).
      etrans.
      {
        apply maponpaths_2.
        apply (free_alg_sem_endpoint_UU_natural (path_left _ _)).
      }
      simpl.
      refine (!(path_assoc _ _ _) @ _).
      etrans.
      {
        apply maponpaths_2.
        apply maponpathsinv0.
      }
      use path_inv_rotate_ll.
      refine (!_).
      do 2 refine (path_assoc _ _ _ @ _).
      etrans.
      {
        apply maponpaths_2.
        etrans.
        {
          apply maponpaths_2.
          refine (!_).
          apply maponpathscomp0.
        }
        etrans.
        {
          refine (!_).
          apply maponpathscomp0.
        }
        apply maponpaths.
        exact (!(path_assoc _ _ _)).
      }
      refine (path_assoc _ _ _ @ _).
      etrans.
      {
        apply maponpaths_2.
        exact (alg_map_path f j x).
      }
      refine (!(path_assoc _ _ _) @ _ @ path_assoc _ _ _).
      apply maponpaths.
      simpl.
      refine (!_).
      refine (path_assoc _ _ _ @ _).
      etrans.
      {
        apply maponpaths_2.
        apply pathsinv0r.
      }
      apply idpath.
    Qed.

    Definition make_free_alg_mor
      : X --> make_free_alg_algebra Y incY.
    Proof.
      pose Hf.
      use make_algebra_map.
      use make_hit_path_alg_map.
      - exact make_free_alg_prealg_mor.
      - exact make_free_alg_preserves_path.
    Defined.
  End FreeAlgMapBuilder.

  Section FreeAlgCellToComp.
    Context {X : hit_algebra_one_types free_alg_signature}
            {Y : hit_algebra_one_types Σ}
            (Yinc : A → alg_carrier Y)
            (f : free_alg_is_alg X --> Y)
            (Hf : preserves_A f (free_alg_inc X) Yinc).

    Definition free_alg_map_free_alg_is_make_free_alg_carrier
      : alg_map_carrier f
        ~
        alg_map_carrier
          (free_alg_map_alg_mor (make_free_alg_mor Yinc f Hf)
           · free_alg_is_alg_make_free_alg_algebra Y Yinc)
      := homotrefl _.

    Definition free_alg_map_free_alg_is_make_free_alg_is_algebra_2cell
      : is_algebra_2cell free_alg_map_free_alg_is_make_free_alg_carrier.
    Proof.
      intro x.
      cbn ; unfold homotcomp, homotfun, funhomotsec ; simpl.
      rewrite !pathscomp0rid.
      rewrite maponpathsidfun.
      refine (!(path_assoc _ _ _) @ _).
      apply maponpaths.
      rewrite <- maponpathscomp0.
      apply maponpaths.
      apply poly_id_comp.
    Qed.
    
    Definition free_alg_map_free_alg_is_make_free_alg
      : f
        ==>
        free_alg_map_alg_mor (make_free_alg_mor Yinc f Hf)
        · free_alg_is_alg_make_free_alg_algebra Y Yinc.
    Proof.
      use make_algebra_2cell.
      - exact free_alg_map_free_alg_is_make_free_alg_carrier.
      - exact free_alg_map_free_alg_is_make_free_alg_is_algebra_2cell.
    Defined.

    Definition free_alg_map_free_alg_is_make_free_alg_inv_carrier
      : alg_map_carrier (free_alg_map_alg_mor (make_free_alg_mor Yinc f Hf))
        ~
        alg_map_carrier (f · free_alg_is_alg_make_free_alg_algebra_inv Y Yinc)
      := homotrefl _.

    Definition free_alg_map_free_alg_is_make_free_alg_inv_is_algebra_2cell
      : is_algebra_2cell free_alg_map_free_alg_is_make_free_alg_inv_carrier.
    Proof.
      intro x.
      cbn ; unfold homotcomp, homotfun, funhomotsec ; simpl.
      rewrite !pathscomp0rid.
      rewrite maponpathsidfun.
      refine (!(path_assoc _ _ _) @ _).
      apply maponpaths.
      rewrite <- maponpathscomp0.
      apply maponpaths.
      apply poly_id_comp.
    Qed.
      
    Definition free_alg_map_free_alg_is_make_free_alg_inv
      : free_alg_map_alg_mor (make_free_alg_mor Yinc f Hf)
        ==>
        f · free_alg_is_alg_make_free_alg_algebra_inv Y Yinc.
    Proof.
      use make_algebra_2cell.
      - exact free_alg_map_free_alg_is_make_free_alg_inv_carrier.
      - exact free_alg_map_free_alg_is_make_free_alg_inv_is_algebra_2cell.
    Defined.
  End FreeAlgCellToComp.
  
  Definition alg_2cell_carrier_free_alg_map_free_alg_is_make_free_alg
             {X : hit_algebra_one_types free_alg_signature}
             {Y : hit_algebra_one_types Σ}
             (Yinc : A → alg_carrier Y)
             (f : free_alg_is_alg X --> Y)
             (Hf : preserves_A f (free_alg_inc X) Yinc)
    : alg_2cell_carrier (free_alg_map_free_alg_is_make_free_alg Yinc f Hf)
      =
      homotrefl _
    := idpath _.

  Definition alg_2cell_carrier_free_alg_map_free_alg_is_make_free_alg_inv
             {X : hit_algebra_one_types free_alg_signature}
             {Y : hit_algebra_one_types Σ}
             (Yinc : A → alg_carrier Y)
             (f : free_alg_is_alg X --> Y)
             (Hf : preserves_A f (free_alg_inc X) Yinc)
    : alg_2cell_carrier (free_alg_map_free_alg_is_make_free_alg_inv Yinc f Hf)
      =
      homotrefl _
    := idpath _.

  (** Projections of 2-cells *)
  Section FreeAlgCellProjections.
    Context {X Y : hit_algebra_one_types free_alg_signature}
            {f g : X --> Y}
            (τ : f ==> g).

    Definition free_alg_cell_alg_cell
      : free_alg_map_alg_mor f ==> free_alg_map_alg_mor g.
    Proof.
      use make_algebra_2cell.
      - exact (alg_2cell_carrier τ).
      - abstract
          (intro x ;
           cbn in x ;
           refine (alg_2cell_commute τ (inl x) @ _) ; simpl ;
           apply maponpaths ;
           apply maponpathscomp).
    Defined.

    Definition free_alg_cell_on_A
               (a : A)
      : alg_2cell_carrier τ (alg_constr X (inr a)) @ alg_map_commute g (inr a)
        =
        alg_map_commute f (inr a).
    Proof.
      exact (alg_2cell_commute τ (inr a) @ pathscomp0rid _).
    Qed.
  End FreeAlgCellProjections.

  (** Builder of 2-cells *)
  Section FreeAlgCellBuilder.
    Context {X Y : hit_algebra_one_types free_alg_signature}
            {f g : X --> Y}
            (τ : free_alg_map_alg_mor f ==> free_alg_map_alg_mor g)
            (Hτ : ∏ (a : A),
                  alg_2cell_carrier τ (alg_constr X (inr a)) @ alg_map_commute g (inr a)
                  =
                  alg_map_commute f (inr a)).

    Definition make_free_alg_cell
      : f ==> g.
    Proof.
      use make_algebra_2cell.
      - exact (alg_2cell_carrier τ).
      - abstract
          (intros x ;
           induction x as [x | x] ;
           [ refine (alg_2cell_commute τ x @ _) ; simpl ;
             apply maponpaths ;
             refine (!_) ;
             apply (maponpathscomp inl)
           | simpl ;
             exact (Hτ x @ !(pathscomp0rid _))]).
    Defined.
  End FreeAlgCellBuilder.

  (** Mapping principles of free algebra *)
  Section FreeAlgMapping.
    Variable (X : hit_algebra_one_types free_alg_signature)
             (HX : is_initial _ X).

    (** Mapping principle for 1-cells *)
    Section FreeAlgMapUMPOne.
      Variable (Y : hit_algebra_one_types Σ)
               (Yinc : A → alg_carrier Y).

      Definition free_alg_ump_1_free_alg_map
        : X --> make_free_alg_algebra Y Yinc
        := biinitial_1cell
             _
             HX
             (make_free_alg_algebra Y Yinc).
      
      Definition free_ump_1
        : free_alg_is_alg X --> Y
        := free_alg_map_alg_mor free_alg_ump_1_free_alg_map
           · free_alg_is_alg_make_free_alg_algebra Y Yinc.

      Definition free_alg_one_cell_on_A
                 (a : A)
        : alg_map_carrier free_alg_ump_1_free_alg_map (free_alg_inc X a)
          =
          Yinc a
        := free_alg_map_on_A free_alg_ump_1_free_alg_map a.
    End FreeAlgMapUMPOne.

    (** Mapping principle for 2-cells. *)
    Section FreeAlgMapUMPTwo.
      Variable (Y : hit_algebra_one_types Σ)
               (Yinc : A → alg_carrier Y)
               (f g : free_alg_is_alg X --> Y)
               (Hf : preserves_A f (free_alg_inc X) Yinc)
               (Hg : preserves_A g (free_alg_inc X) Yinc).

      Definition free_alg_ump_2_alg_cell
        : make_free_alg_mor Yinc f Hf ==> make_free_alg_mor Yinc g Hg
        := pr1 (@biinitial_2cell
                  _ _
                  X
                  HX
                  (make_free_alg_algebra Y Yinc)
                  (make_free_alg_mor Yinc f Hf)
                  (make_free_alg_mor Yinc g Hg)).

      Definition free_alg_ump_2
        : f ==> g
        := free_alg_map_free_alg_is_make_free_alg Yinc f Hf
           • (free_alg_cell_alg_cell free_alg_ump_2_alg_cell
              ▹ free_alg_is_alg_make_free_alg_algebra Y Yinc)
           • (hit_alg_is_invertible_2cell_one_type
                Σ
                (free_alg_map_free_alg_is_make_free_alg Yinc g Hg))^-1.

      Definition free_alg_ump_2_on_A
                 (a : A)
        : alg_2cell_carrier free_alg_ump_2 (alg_constr X (inr a))
          @ Hg a
          =
          Hf a.
      Proof.
        unfold free_alg_ump_2.
        rewrite !alg_2cell_vcomp.
        unfold homotcomp.
        etrans.
        {
          do 3 apply maponpaths_2.
          exact (eqtohomot
                   (alg_2cell_carrier_free_alg_map_free_alg_is_make_free_alg
                      Yinc f Hf) _).
        }
        unfold homotrefl.
        etrans.
        {
          do 2 apply maponpaths_2.
          apply pathscomp0lid.
        }
        etrans.
        {
          do 2 apply maponpaths_2.
          exact (eqtohomot
                   (alg_2cell_rwhisker
                      (free_alg_cell_alg_cell free_alg_ump_2_alg_cell)
                      (free_alg_is_alg_make_free_alg_algebra Y Yinc))
                   _).
        }
        etrans.
        {
          do 2 apply maponpaths_2.
          apply maponpathsidfun.
        }
        etrans.
        {
          apply maponpaths_2.
          apply maponpaths.
          exact (eqtohomot
                   (alg_2cell_inv
                      (free_alg_map_free_alg_is_make_free_alg Yinc g Hg))
                   _).
        }
        unfold invhomot.
        etrans.
        {
          apply maponpaths_2.
          do 2 apply maponpaths.
          exact (eqtohomot
                   (alg_2cell_carrier_free_alg_map_free_alg_is_make_free_alg
                      Yinc g Hg)
                   _).
        }
        unfold homotrefl.
        etrans.
        {
          apply maponpaths_2.
          apply pathscomp0rid.
        }
        refine (alg_2cell_commute free_alg_ump_2_alg_cell (inr a) @ _) ; simpl.
        apply pathscomp0rid.
      Qed.
    End FreeAlgMapUMPTwo.

    (** Mapping principles for equalities *)
    Local Definition free_alg_ump_eq_help_cell
          (Y : hit_algebra_one_types Σ)
          (Yinc : A → alg_carrier Y)
          (f g : free_alg_is_alg X --> Y)
          (Hf : preserves_A f (free_alg_inc X) Yinc)
          (Hg : preserves_A g (free_alg_inc X) Yinc)
          (τ : f ==> g)
          (Hτ : ∏ (a : A),
                alg_2cell_carrier τ (alg_constr X (inr a)) @ Hg a
                =
                Hf a)
      : make_free_alg_mor Yinc f Hf ==> make_free_alg_mor Yinc g Hg.
    Proof.
      simple refine
             (@make_free_alg_cell
                X
                (make_free_alg_algebra Y Yinc)
                (make_free_alg_mor Yinc f Hf)
                (make_free_alg_mor Yinc g Hg)
                (free_alg_map_free_alg_is_make_free_alg_inv Yinc f Hf
                 • (τ ▹ free_alg_is_alg_make_free_alg_algebra_inv Y Yinc)
                 • ((hit_alg_is_invertible_2cell_one_type
                       Σ
                       (free_alg_map_free_alg_is_make_free_alg_inv Yinc g Hg))^-1))
                _).
      abstract
        (intro a ;
         cbn ;
         unfold homotcomp, invhomot, homotfun ;
         cbn ;
         rewrite pathscomp0rid ;
         rewrite maponpathsidfun ;
         exact (Hτ a)).
    Defined.

    Local Definition alg_2cell_carrier_free_alg_ump_eq_help_cell
          (Y : hit_algebra_one_types Σ)
          (Yinc : A → alg_carrier Y)
          (f g : free_alg_is_alg X --> Y)
          (Hf : preserves_A f (free_alg_inc X) Yinc)
          (Hg : preserves_A g (free_alg_inc X) Yinc)
          (τ : f ==> g)
          (Hτ : ∏ (a : A),
                alg_2cell_carrier τ (alg_constr X (inr a)) @ Hg a
                =
                Hf a)
          (x : alg_carrier X)
      : alg_2cell_carrier
          (free_alg_ump_eq_help_cell Y Yinc f g Hf Hg τ Hτ)
          x
        =
        alg_2cell_carrier τ x.
    Proof.
      unfold free_alg_ump_eq_help_cell.
      cbn.
      unfold homotcomp, invhomot, homotfun.
      rewrite maponpathsidfun.
      unfold free_alg_map_free_alg_is_make_free_alg_inv_carrier ; cbn.
      apply pathscomp0rid.
    Qed.          
    
    Section FreeAlgMapUMPEq.
      Variable (Y : hit_algebra_one_types Σ)
               (Yinc : A → alg_carrier Y)
               (f g : free_alg_is_alg X --> Y)
               (Hf : preserves_A f (free_alg_inc X) Yinc)
               (Hg : preserves_A g (free_alg_inc X) Yinc)
               (τ θ : f ==> g)
               (Hτ : ∏ (a : A),
                     alg_2cell_carrier τ (alg_constr X (inr a)) @ Hg a
                     =
                     Hf a)
               (Hθ : ∏ (a : A),
                     alg_2cell_carrier θ (alg_constr X (inr a)) @ Hg a
                     =
                     Hf a).
        
      Definition free_alg_ump_eq
        : τ = θ.
      Proof.
        use algebra_2cell_eq.
        intro x.
        pose (@biinitial_eq
                _ _ X HX
                (make_free_alg_algebra Y Yinc)
                (make_free_alg_mor Yinc f Hf)
                (make_free_alg_mor Yinc g Hg)
                (free_alg_ump_eq_help_cell Y Yinc f g Hf Hg τ Hτ)
                (free_alg_ump_eq_help_cell Y Yinc f g Hf Hg θ Hθ))
          as p₁.
        pose (alg_2cell_eq_component p₁ x) as p₂.
        refine (!_ @ p₂ @ _).
        - apply alg_2cell_carrier_free_alg_ump_eq_help_cell.
        - apply alg_2cell_carrier_free_alg_ump_eq_help_cell.
      Qed.
    End FreeAlgMapUMPEq.
  End FreeAlgMapping.
End FreeAlg.
